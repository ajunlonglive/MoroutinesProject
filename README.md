# Moroutines
Moroutines - More Than Coroutines, это библиотека C# написанная для Unity для работы с корутинами. 

Unity по умолчанию предоставляет возможность работы с корутинами, однако этот подход имеет недостатки. С помощью этой библиотеки мы попытались обойти эти недостатки 
предлагая вам собственное API для работы с корутинами. Тем не менее, наша библиотека используется Unity-корутины чтобы организовать псевдопараллельное выполнение ваших функций.
Вы можете использовать одновременно как встроенный подход для работы с корутинами, так и нашу библиотеку.

### Почему морутина?
В Unity уже существует класс `Coroutine` для работы с корутинами и у нас было несколько путей реализации нашей библиотеки. Мы решили идти по пути наименьшего сопротивления и ровно по этой причине в нашей библиотеке корутины называются иначе - морутины. Это позволяет вам легко использовать как встроенные в Unity корутины используя класс `Coroutine`, так и более продвинутые морутины из нашей библиотеки используя класс `Moroutine`.

### Какие преимущества?
Встроенный подход работы с корутинами имеет несколько недостатков:
- Одну корутину может ожидать только другая одна корутина, в противном случае (если ожидающих больше одной), Unity сообщит вам об ошибке в консоли в процессе выполнения игры.
- Нет возможности по объекту класса `Coroutine` узнать о состоянии корутины (выполняется, приостановлена или завершена).
- Нет возможности приостановить или перезапустить корутину по объекту класса `Coroutine`.
- Нет возможности создать корутину с отложенным запуском.
- Нет возможности ожидания паузы или возобнавления корутины.
- Нет возможности подписаться на события изменения состояния корутины.
- Нет возможности получить последний результат корутины.
- И прочие...

Наша библиотека исключена недостатков перечисленных выше. Вы можете легко управлять корутиной всего парой строчек кода, определять ее состояние, реагировать на события и так далее.

### Импорт библиотеки
Вы можете импортировать нашу библиотеку с помощью магазина Asset Store или клонируя репозиторий отсюда на свой компьютер. Если вы решили клонировать репозиторий, то все что вам надо
сделать - это скопировать папку `Plugins` в папку `Assets` вашего проекта. После этого вам станут доступны все необходимые классы для работы с корутинами.
> Не извлекайте содержимое папки `Plugins` в другое место, это сделает некоторые `internal` классы доступными для вас, что может привести к ошибкам в будущем. 

### Подключение пространства имен
Для работы с корутинами необходимо подключить пространство имен `Moroutines`. В этом пространстве находятся все типы данных которые мы создали для работыс продвинутыми корутинами.
```
using Moroutines;
```
После этого вы можете использовать класс Moroutine из данной библиотеки для работы с корутинами.

### Создание продвинутой корутины
Чтобы создать корутину вам нужен объект IEnumerator. Как вы возможно знаете, такой объект проще всего создать с помощью инструкции `yield` внутри метода возвращающего IEnumerator.
```
private IEnumerator TickEnumerator()
{
    while (true)
    {
        yield return new WaitForSeconds(1f);
        print("Tick!");
    }
}
```
В примере выше объявлен метод в котором бесконечно с секундной задержкой выводится текст "Tick!" в консоль Unity. Чтобы запустить его встроенным в Unity способом вы бы использовали метод `StartCoroutine`, однако данный метод вернул бы вам объект `UnityEngine.Coroutine`, который не предоставляет никакой информации о состоянии корутины. Вместо этого, вы должны использовать метод `Moroutine.Create`.
```
Moroutine.Create(TickEnumerator());
```
В этом случае статический метод `Moroutine.Create` вернет вам продвинутый объект корутины с множеством методов и свойств для работы с ней. В целом скрипт с вышеперечисленными примерами кода
будет выглядеть так.
```
using System.Collections;
using UnityEngine;
using Moroutines;

public class Test : MonoBehaviour
{
    private void Start()
    {
        Moroutine.Create(TickEnumerator());
    }

    private IEnumerator TickEnumerator()
    {
        while (true)
        {
            yield return new WaitForSeconds(1f);
            print("Tick!");
        }
    }
}
```
Но если вы попробуете запустить этот код, то ничего не произойдет. Это потому, что метод `Moroutine.Create` создает корутину и возвращает ее, но не запускает процесс ее выполнения.

### Запуск выполнения продвинутой корутины
Вы можете запустить ее вызвав метод `Run` как в примере ниже.
```
var mor = Moroutine.Create(TickEnumerator());
mor.Run();
```
Пример выше можно сократить используя цепочку вызовов методов.
```
Moroutine.Create(TickEnumerator()).Run();
```
Этот пример тоже можно сократить, используя статический метод `Moroutine.Run`.
```
Moroutine.Run(TickEnumerator());
```
Используйте метод `Moroutine.Run` если вам надо создать корутину и сразу запустить ее. Полный пример кода выглядит так.
```
using System.Collections;
using UnityEngine;
using Moroutines;

public class Test : MonoBehaviour
{
    private void Start() => Moroutine.Run(TickEnumerator());

    private IEnumerator TickEnumerator()
    {
        while (true)
        {
            yield return new WaitForSeconds(1f);
            print("Tick!");
        }
    }
}
```
> Метод Moroutine.Run также возвращает объект морутины, поэтому вы можете использовать его не только для запуска, но и для дальнейших манипуляций.

Если запустить игру с этим скриптом, то в консоли каждую секунду будут появляться сообщения "Tick!".

![Снимок экрана 2021-08-17 211846](https://user-images.githubusercontent.com/5365111/129779572-6c2d7d0d-0c49-4556-918c-5541c0025d13.jpg)

### Остановка морутины
Чтобы остановить морутину используйте метод `Stop` на объекте морутины.
```
var mor = Moroutine.Run(TickEnumerator());  // Запускаем

yield return new WaitForSeconds(1f);        // Ждем 1 секунду
mor.Stop();                                 // Останавливаем
```
### Продолжение морутины
Если необходимо продолжить морутину после остановки, то снова вызовите метод Run на ней.
```
var mor = Moroutine.Run(TickEnumerator());  // Запускаем

yield return new WaitForSeconds(1f);        // Ждем 1 секунду
mor.Stop();                                 // Останавливаем

yield return new WaitForSeconds(3f);        // Ждем 3 секунды
mor.Run();                                  // Продолжаем
```

### Перезапуск морутины
Вы можете перезапустить морутину (начать ее выполнение с начала) используя метод `Reset`. Но перед тем как использовать его имейте в виду, что метод возвращающий IEnumerator и
использующий оператор `yield` в своем теле генерирует `IEnumerator` объект, который реализует свойство `Current` и метод `MoveNext`, но не реализует метод `Reset`. По этой причине
морутины, выполняющие такие методы, при попытке перезапустить их будут просто продолжать выполнение. Чтобы сделать возможным перезапусе морутины, необходимо использовать IEnumerable вместо IEnumerator в определении возвращаемого значения метода морутины.
> Мы рекомендуем использовать IEnumerable вместо IEnumerator везде, где вы пишете методы морутин, это позволит избежать неясных ошибок в будущем.
```
private IEnumerator Start()
{
    var mor = Moroutine.Run(CountEnumerable());     // Запуск морутины

    yield return new WaitForSeconds(2.5f);          // Ждем 2.5 секунды
    mor.Reset();                                    // Обнуляем состояние морутины
    mor.Run();                                      // Запускаем морутину снова
}

private IEnumerable CountEnumerable()               // Обратите внимание, что метод возвращает IEnumerable
{
    for (int i = 1; i <= 3; i++)
    {
        yield return new WaitForSeconds(1f);
        print(i);
    }
}

```

![image](https://user-images.githubusercontent.com/5365111/129790030-1a9d8bc9-233a-4cee-9077-f8a4757dfef3.png)

Обратите внимание, что вызов метода Reset обнуляет состояние морутины и останавливает ее. Это значит вы сами должны позаботиться о ее дальнейшем запуске. Методы `Run`, `Stop` и
`Reset` возвращают морутину, которой они принадлежат, это позволяет сцепить несколько вызовов методов друг с другом и сократить код.
```
mor.Reset().Run();
```
После выполнения морутины вы также можете вызвать метод `Reset` на ней, чтобы снова использовать, однако в этом случае это скорее всего будет лишним. Вместо этого просто используйте метод `Run`, он имеет параметр `rerunIfCompleted`, который можно использовать если надо повторно воспроизвести корутину после завершения. По умолчанию этот параметр имеет значение `true`.

### Состояние морутины
Вы можете проверить состояние морутины с помощью следующих свойств:
- `IsReseted` - обнулена ли морутина.
- `IsRunning` - запущена ли морутина.
- `IsStopped` - остановлена ли морутина.
- `IsCompleted` - завершена ли морутина.
- `CurrentState` - возвращает перечисление, которое представляет одно из вышеперечисленных состояний.

Первые четыре возвращают булево значение, представляющее соответствующее состояние. Пример:
```
var mor = Moroutine.Run(CountEnumerable());
print(mor.IsRunning);
```

### События и методы подписки
Морутины имеют следующие события:
- `Reseted` - срабатывает когда морутина сбрасывается в начальное состояние.
- `Running` - срабатывает сразу после вызова метода `Run`.
- `Stopped` - срабатывает только когда морутина останавливается (но не завершается).
- `Completed` - срабатывает когда корутина завершается.

Вы можете подписаться на любое из этих событий когда это необходимо. Метод-подписчик должен соответствовать следующей сигнатуре:
```
void EventHandler(Moroutine moroutine);
```
В параметр `moroutine` будет подставлена корутина вызвавшая событие.
```
var mor = Coroutine.Run(CountEnumerable());
mor.Completed += mor => print("Completed");
```
Вы также можете быстро подписаться на нужное событие с помощью следющих методов:
- OnReseted - подписка на обнуление.
- OnRunning - подписка на запуск.
- OnStopped - подписка на остановку.
- OnCompleted - подписка на завершение.

```
var mor = Moroutine.Run(CountEnumerable());
mor.OnCompleted(c => print("Completed"));
```
Все эти методы возвращают морутину на которой они вызываются, поэтому вы можете формировать длинные цепочки вызовов, например такие:
```
Moroutine.Create(CountEnumerable()).OnCompleted(c => print("Completed")).Run();
```

### Ожидание морутины
Если необходимо подождать определенное состояние морутины, то используйте следующие методы:
- WaitForComplete - возвращает объект для ожидания завершения.
- WaitForStop - возвращает объект для ожидания остановки.
- WaitForRun - возвращает объект для ожидания запуска.
- WaitForReset - возвращает объект для ожидания обнуления.

Вызовите вышеперечисленные методы для того, чтобы подождать нужное состояние, например:
```
var mor = Moroutine.Run(CountEnumerable());

yield return mor.WaitForComplete();             // ждем пока морутина завершится
print("Awaited");                               // выводим текст после завершения морутины
```
Пример выше можно сократить до такого:
```
yield return Moroutine.Run(CountEnumerable()).WaitForComplete();
print("Awaited");
```
Во встроенном движке корутин вы были ограничены в количестве ожидающих корутин, то есть одну корутину могла ждать только одна другая корутина, например такой код сообщил бы об ошибке ожидания второй корутиной:
```
private void Start()
{
    var coroutine = StartCoroutine(SomeEnumerator());    // первая корутина, имитирует некий процесс
    StartCoroutine(WaitEnumerator(coroutine));           // вторая корутина, ждет первую, все ок
    StartCoroutine(WaitEnumerator(coroutine));           // третья корутина, ждет первую, ошибка
}

private IEnumerator SomeEnumerator()
{
    yield return new WaitForSeconds(3f); // имитируем некий процесс выполнения..
}

private IEnumerator WaitEnumerator(Coroutine coroutine)
{
    yield return coroutine;
    print("Awaited");
}

```

![image](https://user-images.githubusercontent.com/5365111/129798948-97ad275f-1c06-4983-83a2-ab293673347d.png)

Как видите, это действительно так, однако с морутинами такой проблемы нет, вы можете создавать сколько угодно морутин, которые будут ожидать какие угодно другие морутины!
```
private void Start()
{
    var mor = Moroutine.Run(SomeEnumerable());
    Moroutine.Run(WaitEnumerable(mor));
    Moroutine.Run(WaitEnumerable(mor));      
}

private IEnumerable SomeEnumerable()
{
    yield return new WaitForSeconds(3f);
}

private IEnumerable WaitEnumerable(Moroutine moroutine)
{
    yield return moroutine.WaitForComplete();
    print("Awaited");
}

```

![image](https://user-images.githubusercontent.com/5365111/129799598-7ebef6dc-a78b-4174-858a-07338e400a3f.png)

### Результат морутины
Вы также можете без проблем получить последний объект, который был установлен в свойство `Current` сгенерированного перечислителя через свойство `LastResult` у морутины.

```
private IEnumerator Start()
{
    var mor = Moroutine.Run(_owner, GenerateSomeResultEnumerable());
    yield return mor.WaitForComplete(); // ждем морутину.
    
    print(mor.LastResult); // выводим ее последний результат.
}

private IEnumerable GenerateSomeResultEnumerable()
{
    yield return new WaitForSeconds(3f); // симулируем некий процесс..
    yield return "Hello from moroutine!"; // а это будет последним результатом морутины.
}

```

![image](https://user-images.githubusercontent.com/5365111/141380042-0a009674-c783-4c24-8083-15acb3d6513f.png)

Иногда это бывает очень удобно!

### Бесхозные морутины
До сих пор мы с вами изучали как создавать бесхозные морутины. Бесхозная морутина - это морутина, которая не привязана ни к одному игровому объекту. Выполнение такой морутины не может быть прервано, кроме как с помощью методов `Stop` или `Reset`. 

### Морутины и их владельцы
Вы можете связать морутину с любым игровым объектом, то есть сделать этот игровой объект хозяином морутины. Это значит, что выполнение морутины будет возможным только в случае если объект-хозяин активен, в противном случае морутина будет остановлена и вы не сможете перезапустить ее или продолжить до тех пор пока объект-хозяин не станет активен. Попытка запуска морутины на неактивном объекте-хозяине сгенерирует исключение. Если объект-хозяин вновь активен, то вы можете продолжить выполнение морутины используя метод `Run`.

Чтобы указать хозяина морутины укажите его первым параметром в методах `Moroutine.Create` или `Moroutine.Run`.
```
var mor = Moroutine.Run(gameObject, CountEnumerable()); // gameObject - это хозяин корутины
```
> Вы не можете изменить хозяина морутины после того как морутина была создана.

Если вам необходимо получить хозяина морутины, то вы можете использовать свойство `Owner` у объекта морутины.
```
var mor = Moroutine.Run(gameObject, CountEnumerable());
print(mor.Owner.name);
```

### Объект `MoroutinesOwner`
На самом деле **запуск** (именно запуск, с помощью метода `Run`) любой морутины будет происходить на объекте `MoroutinesOwner` (то есть внутри метода `Run` есть такая строка кода `MoroutinesOwner.Instance.StartCoroutine(RunEnumerator())`), однако он хорошо спрятан от вас и вам не нужно как либо пытаться найти его и что-либо с ним делать. Перед самым запуском вашей игры в сцене будет создан объект `MoroutinesOwner`, который будет изолирован в `DontDestroyOnLoad` сцену и скрыт в ней, так, что вы и не заметите этого. 
- Все бесхозные морутины принадлежат и запускаются на объекте `MoroutinesOwner`. 
- Морутины с хозяином принадлежат своим объектам-хозяинам, а запускаются на объекте `MoroutinesOwner`.
> Не пытайтесь как либо повлиять на объект `MoroutinesOwner`.

### Как устроено отслеживание деактивации объектов-хозяинов
Для отслеживания деактивации хозяинов морутин к ним (хозяевам) добавляется скрипт `DeactivationObserver`, который в случае деактивации объекта испускает событие `Deactivated`, на которое в заранее подписана связанная с этим хозяином морутина. Морутина реагирует на событие деактивации и вызывает метод `Stop` на себе, что приводит к остановке состояния морутины.

Однако вы сможете увидеть этот скрипт на объекте только если переключите окно инспектора в режим отладки.

![image](https://user-images.githubusercontent.com/5365111/156012399-b7f60332-71f3-445a-9b02-a5d57e905cb4.png)

### Вспомогательный класс `Routines`
Статический класс `Routines` хранит в себе наиболее часто используемые методы для организации логики выполнения морутин. Все методы генерируют и возвращают объект `IEnumerable`, который можно использовать подставляя в другие методы. В частности имеются следующие методы:
- `Delay` - добавляет временную задержку перед выполнением морутины.
- `FrameDelay` - добавляет кадровую задержку перед выполнением морутины.
- `Repeat` - повторяет морутину указанное количество раз.
- `Wait` - ожидает выполнение объектов `YieldInstruction` и `CustomYieldInstruction`.

Пример с `Delay`:
```
private void Start() => Moroutine.Run(Routines.Delay(1f, CountEnumerable()));

private IEnumeraable CountEnumerable()
{
    for (int i = 1; i <= 3; i++)
    {
        yield return new WaitForSeconds(1f);
        print(i);
    }
}
```
В этот примере используется метод `Delay`, который добавляет секундную задержку перед выполнением перечислителя `CountEnumerator`, для этого используется строка `Routines.Delay(1f, CountEnumerable())`. Как уже говорилось выше, все методы класса `Routines` возвращают объект `IEnumerable`, поэтому, чтобы сделать из результата склейки методов `Delay` и `CountEnumerable` морутину, нужно подставить его (результат) в метод `Moroutine.Run`.

Метод `Delay` умеет также работать с Action-методами, что по сути дает вам возможность быстро организовать отложенное выполнение нужного вам метода, например:
```
private void Start() => Moroutine.Run(Routines.Delay(1f, () => print("Delayed print!")));
```

или
```
private void Start() => Moroutine.Run(Routines.Delay(1f, () => Welcome("Andrew", 29)));

private void Welcome(string name, int age) => print($"Hello {name}, you are {age} years old!");
```

![image](https://user-images.githubusercontent.com/5365111/129882932-0ade0009-9599-4226-9567-046fa6a91762.png)

Как видите это очень удобно и сокращено дублирование кода.
> Данные методы могут работать как с `IEnumerable` так и с `IEnumerator` объектами (в некоторых случаях есть исключения, совсем не важные случаи), однако, если вы планируете перезапуск ваших перечислителей, то необходимо использовать `IEnumerable` объекты. Мы рекомендуем всегда использовать генерацию `IEnumerable` объекта вместо `IEnumerator`.

Метод `FrameDelay` добавляет кадровую задежку перед выполнение перечислителя. К примеру, если нужно подождать 1 игровой кадр, а затем выполнить код перечислителя, то это будет выглядеть так:
```
private void Start() => Moroutine.Run(Routines.FrameDelay(1, () => print("1 frame skipped!")));
```
Данный метод также как и метод `Delay` умеет работать с Action-методами.

Метод `Repeat` повторяет указанный перечислитель указанное количество раз. Если вам нужно бесконечное повторение выполнения перечислителя, то укажите -1 в качестве параметра `count` метода `Repeat`. Пример:
```
private void Start() => Moroutine.Run(Routines.Repeat(3, WaitAndPrintEnumerator()));

private IEnumerable WaitAndPrintEnumerator()
{
    yield return new WaitForSeconds(1f);
    print("Hello!");
}
```
В результате в консоль 3 раза через каждую секунду будет выведен текст "Hello!".

![image](https://user-images.githubusercontent.com/5365111/129884060-ffa723c8-c7c7-4fe7-8400-e7b3dc37ee40.png)

Вы можете комбинировать методы `Delay`, `FrameDelay` и `Repeat` между собой, например, если нужно выполнить некую функцию 3 раза с задержкой в 1 секунду, то это будет выглядеть так:
```
private void Start() => Moroutine.Run(Routines.Repeat(3, Routines.Delay(1f, () => print(Time.time))));
```

![image](https://user-images.githubusercontent.com/5365111/129884562-3ad492a7-de74-466f-be0e-3cbe27654555.png)

Такое вложение методов друг в друга может быть неограниченным.

Метод `Wait` позволяет быстро обернуть `YieldInstrution` или `CustomYieldInstruction` объект в `IEnumerable`, который просто будет ждать их выполнения. Например, если вы хотите обернуть `YieldInstruction` объект в корутину, чтобы в дальнейшем следить за состоянием выполнения `YieldInstruction` через эту корутину, то вы можете написать такой код:
```
var moroutine = Moroutine.Run(Routines.Wait(instruction));
```
Где `instruction` это объект класса `YieldInstruction`.

### Расширения
Помимо основного пространства имен существует еще и пространство имен `Moroutines.Extensions`, в котором находятся методы расширения для классов `YieldInstruction` и `CustomYieldInstruction`. Эти методы позволяют быстро конвертировать `Moroutine`, `YieldInstruction` и `CustomYieldInstruction` друг в друга. Например:
```
var delayMoroutine = Moroutine.Run(Routines.Delay(1f, () => print("Converting")));  // Создали морутину

var yieldInstruction = delayMoroutine.WaitForComplete();                            // Получили YieldInstruction объект
var customYieldInstruction = yieldInstruction.AsCustomYieldInstruction();           // YieldInstruction конвертировали в CustomYieldInstruction
var moroutine = customYieldInstruction.AsMoroutine();                               // CustomYieldInstruction конвертировали в новый объект Moroutine
```

Такое преобразование скорее всего редко вам понадобится, однако возможность имеется.

Все! Теперь вы готовы использовать наш движок корутин, удачи!
