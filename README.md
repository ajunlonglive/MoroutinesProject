# Coroutines
Coroutines - это библиотека C# написанная для Unity для работы с корутинами. 

Unity по умолчанию предоставляет возможность работы с корутинами, однако этот подход имеет недостатки. С помощью этой библиотеки мы попытались обойти эти недостатки 
предлагая вам собственное API для работы с корутинами. Тем не менее, наша библиотека используется Unity-корутины чтобы организовать псевдопараллельное выполнение ваших функций.
Вы можете использовать одновременно как встроенный подход для работы с корутинами, так и нашу библиотеку.

Встроенный подход работы с корутинами имеет несколько недостатков:
- Одну корутину может ожидать только другая одна корутина, в противном случае (если ожидающих больше одной), Unity сообщит вам об ошибке в консоли в процессе выполнения игры.
- Нет возможности по объекту класса `Coroutine` узнать о состоянии корутины (выполняется, приостановлена или завершена).
- Нет возможности приостановить или перезапустить корутину по объекту класса `Coroutine`.
- Нет возможности создать корутину с отложенным запуском.
- Нет возможности ожидания паузы или возобнавления корутины.
- Нет возможности подписаться на события изменения состояния корутины.
- И прочие...

Наша библиотека исключена недостатков перечисленных выше. Вы можете легко управлять корутиной всего парой строчек кода, определять ее состояние, реагировать на события и так далее.

### Импорт библиотеки
Вы можете импортировать нашу библиотеку с помощью магазина Asset Store или клонируя репозиторий отсюда на свой компьютер. Если вы решили клонировать репозиторий, то все что вам надо
сделать - это скопировать папку `Plugins` в папку `Assets` вашего проекта. После этого вам станут доступны все необходимые классы для работы с корутинами.
> Не извлекайте содержимое папки `Plugins` в другое место, это сделает некоторые `internal` классы доступными для вас, что может привести к ошибкам в будущем. 

### Подключение пространства имен
Для работы с корутинами необходимо подключить пространство имен `Coroutines`. В этом пространстве находятся все типы данных которые мы создали для работыс продвинутыми корутинами.
```
using Coroutines;
```
После этого вы можете использовать класс Coroutine из данной библиотеки для работы с корутинами, однако если вы попробуете использовать его, то получите ошибку времени компиляции.
Дело в том, что класс `Coroutines.Coroutine` конфликтует со встроенным классом `UnityEngine.Coroutine`. Вы можете обойти эту ошибку разными способами, однако мы рекомендуем
добавить явное связывание имени `Coroutine` с классом `Coroutines.Coroutine` сразу после подключения пространств имен.
```
using Coroutine = Coroutines.Coroutine;
```

### Создание продвинутой корутины
Чтобы создать корутину вам нужен объект IEnumerator. Как вы возможно знаете, такой объект проще всего создать с помощью инструкции `yield` внутри метода возвращающего IEnumerator.
```
private IEnumerator TickEnumerator()
{
    while (true)
    {
        yield return new WaitForSeconds(1f);
        print("Tick!");
    }
}
```
В примере выше объявлен метод в котором бесконечно с секундной задержкой выводится текст "Tick!" в консоль Unity. Чтобы запустить его встроенным в Unity способом вы бы использовали метод `StartCoroutine`, однако данный метод вернул бы вам объект `UnityEngine.Coroutine`, который не предоставляет никакой информации о состоянии корутины. Вместо этого, вы должны использовать метод `Coroutine.Create`.
```
Coroutine.Create(TickEnumerator());
```
В этом случае статический метод `Coroutine.Create` вернет вам продвинутый объект корутины с множеством методов и свойств для работы с ней. В целом скрипт с вышеперечисленными примерами кода
будет выглядеть так.
```
using System.Collections;
using UnityEngine;
using Coroutines;
using Coroutine = Coroutines.Coroutine;

public class Test : MonoBehaviour
{
    private void Start()
    {
        Coroutine.Create(TickEnumerator());
    }

    private IEnumerator TickEnumerator()
    {
        while (true)
        {
            yield return new WaitForSeconds(1f);
            print("Tick!");
        }
    }
}
```
Но если вы попробуете запустить этот код, то ничего не произойдет. Это потому, что метод `Coroutine.Create` создает корутину и возвращает ее, но не запускает процесс ее выполнения.

### Запуск выполнения продвинутой корутины
Вы можете запустить ее вызвав метод `Run` как в примере ниже.
```
var cor = Coroutine.Create(TickEnumerator());
cor.Run();
```
Пример выше можно сократить используя цепочку вызовов методов.
```
Coroutine.Create(TickEnumerator()).Run();
```
Этот пример тоже можно сократить, используя статический метод `Coroutine.Run`.
```
Coroutine.Run(TickEnumerator());
```
Используйте метод `Coroutine.Run` если вам надо создать корутину и сразу запустить ее. Полный пример кода выглядит так.
```
using System.Collections;
using UnityEngine;
using Coroutines;
using Coroutine = Coroutines.Coroutine;

public class Test : MonoBehaviour
{
    private void Start() => Coroutine.Run(TickEnumerator());

    private IEnumerator TickEnumerator()
    {
        while (true)
        {
            yield return new WaitForSeconds(1f);
            print("Tick!");
        }
    }
}
```
> Метод Coroutine.Run также возвращает объект корутины, поэтому вы можете использовать его не только для запуска, но и для дальнейших манипуляций.

Если запустить игру с этим скриптом, то в консоли каждую секунду будут появляться сообщения "Tick!".

![Снимок экрана 2021-08-17 211846](https://user-images.githubusercontent.com/5365111/129779572-6c2d7d0d-0c49-4556-918c-5541c0025d13.jpg)

### Остановка корутины
Чтобы остановить корутину используйте метод `Stop` на объекте корутины.
```
var cor = Coroutine.Run(TickEnumerator());  // Запускаем

yield return new WaitForSeconds(1f);        // Ждем 1 секунду
cor.Stop();                                 // Останавливаем
```
### Продолжение корутины
Если необходимо продолжить корутину после остановки, то снова вызовите метод Run на ней.
```
var cor = Coroutine.Run(TickEnumerator());  // Запускаем

yield return new WaitForSeconds(1f);        // Ждем 1 секунду
cor.Stop();                                 // Останавливаем

yield return new WaitForSeconds(3f);        // Ждем 3 секунды
cor.Run();                                  // Продолжаем
```

### Перезапуск корутины
Вы можете перезапустить корутину (начать ее выполнение с начала) используя метод `Reset`. Но перед тем как использовать его имейте в виду, что метод возвращающий IEnumerator и
использующий оператор `yield` в своем теле генерирует `IEnumerator` объект, который реализует свойство `Current` и метод `MoveNext`, но не реализует метод `Reset`. По этой причине
корутины, выполняющие такие методы, при попытке перезапустить их будут просто продолжать выполнение. Чтобы сделать возможным перезапусе корутины, необходимо использовать IEnumerable вместо IEnumerator в определении возвращаемого значения метода корутины.
> Мы рекомендуем использовать IEnumerable вместо IEnumerator везде, где вы пишете методы корутин, это позволит избежать неясных ошибок в будущем.
```
private IEnumerator Start()
{
    var cor = Coroutine.Run(CountEnumerator());     // Запуск корутины

    yield return new WaitForSeconds(2.5f);          // Ждем 2.5 секунды
    cor.Reset();                                    // Обнуляем состояние корутины
    cor.Run();                                      // Запускаем корутину снова
}

private IEnumerable CountEnumerator()               // Обратите внимение, что метод возвращает IEnumerable
{
    for (int i = 1; i <= 3; i++)
    {
        yield return new WaitForSeconds(1f);
        print(i);
    }
}

```

![image](https://user-images.githubusercontent.com/5365111/129790030-1a9d8bc9-233a-4cee-9077-f8a4757dfef3.png)

Обратите внимание, что вызов метода Reset обнуляет состояние корутины и останавливает ее. Это значит вы сами должны позаботиться о ее дальнейшем запуске. Методы `Run`, `Stop` и
`Reset` возвращают корутину, которой они принадлежат, это позволяет сцепить несколько вызовов методов друг с другом и сократить код.
```
cor.Reset().Run();
```
После выполнения корутины вы также можете вызвать метод `Reset` на ней, чтобы снова использовать, однако в этом случае это скорее всего будет лишним. Вместо этого просто используйте метод `Run`, он имеет параметр `rerunIfCompleted`, который можно использовать если надо повторно воспроизвести корутину после завершения. По умолчанию этот параметр имеет значение `true`.

### Состояние корутины
Вы можете проверить состояние корутины с помощью следующих свойств:
- `IsReseted` - обнулена ли корутина.
- `IsRunning` - запущена ли корутина.
- `IsStoped` - остановлена ли корутина.
- `IsCompleted` - завершена ли корутина.
- `CurrentState` - возвращает перечисление, которое представляет одно из вышеперечисленных состояний.

Первые четыре возвращают булево значение, представляющее соответствующее состояние. Пример:
```
var cor = Coroutine.Run(CountEnumerator());
print(cor.IsRunning);
```

### События и методы подписки
Корутины имеют следующие события:
- `Reseted` - срабатывает когда корутина сбрасывается в начальное состояние.
- `Running` - срабатывает сразу после вызова метода `Run`.
- `Stoped` - срабатывает только когда корутина останавливается (но не завершается).
- `Completed` - срабатывает когда корутина завершается.

Вы можете подписаться на любое из этих событий когда это необходимо. Метод-подписчик должен соответствовать следующей сигнатуре:
```
void EventHandler(Coroutine coroutine);
```
В параметр `coroutine` будет подставлена корутина вызвавшая событие.
```
var cor = Coroutine.Run(CountEnumerator());
cor.Completed += cor => print("Completed");
```
Вы также можете быстро подписаться на нужное событие с помощью следющих методов:
- OnReseted - подписка на обнуление.
- OnRunning - подписка на запуск.
- OnStoped - подписка на остановку.
- OnCompleted - подписка на завершение.

```
var cor = Coroutine.Run(CountEnumerator());
cor.OnCompleted(c => print("Completed"));
```
Все эти методы позвращают корутину на которой они вызываются, поэтому вы можете формировать длинные цепочки вызовов, например такие:
```
Coroutine.Create(CountEnumerator()).OnCompleted(c => print("Completed")).Run();
```

### Ожидание корутины
Если необходимо подождать определенное состояние корутины, то используйте следующие методы:
- WaitForComplete - возвращает объект для ожидания завершения.
- WaitForStop - возвращает объект для ожидания остановки.
- WaitForRun - возвращает объект для ожидания запуска.
- WaitForReset - возвращает объект для ожидания обнуления.

Вызовите вышеперечисленные методы для того, чтобы подождать нужное состояние, например:
```
var cor = Coroutine.Run(CountEnumerator());

yield return cor.WaitForComplete();             // ждем пока корутина завершится
print("Awaited");                               // выводим текст после завершения корутины
```
Пример выше можно сократить до такого:
```
yield return Coroutine.Run(CountEnumerator()).WaitForComplete();
print("Awaited");
```
Во встроенном движке корутин вы были ограничены в количестве ожидающих корутин, то есть одну корутину могла ждать только одна корутина, например такой код сообщил бы об ошибке ожидания второй корутиной:
```
private void Start()
{
    var oldCoroutine = StartCoroutine(SomeEnumerator());    // первая корутина, имитирует некий процесс
    StartCoroutine(WaitEnumerator(oldCoroutine));           // вторая корутина, ждет первую, все ок
    StartCoroutine(WaitEnumerator(oldCoroutine));           // третья корутина, ждет первую, ошибка
}

private IEnumerator SomeEnumerator()
{
    yield return new WaitForSeconds(3f); // имитируем некий процесс выполнения..
}

private IEnumerator WaitEnumerator(UnityEngine.Coroutine coroutine)
{
    yield return coroutine;
    print("Awaited");
}

```

![image](https://user-images.githubusercontent.com/5365111/129798948-97ad275f-1c06-4983-83a2-ab293673347d.png)

Как видите, это действительно так, однако с нашей библиотекой такой проблемы нет, вы можете создавать сколько угодно корутин, которые будут ожидать какие угодно другие корутины!
```
private void Start()
{
    var cor = Coroutine.Run(SomeEnumerator());
    Coroutine.Run(WaitEnumerator(cor));
    Coroutine.Run(WaitEnumerator(cor));      
}

private IEnumerator SomeEnumerator()
{
    yield return new WaitForSeconds(3f);
}

private IEnumerator WaitEnumerator(Coroutine coroutine)
{
    yield return coroutine.WaitForComplete();
    print("Awaited");
}

```

![image](https://user-images.githubusercontent.com/5365111/129799598-7ebef6dc-a78b-4174-858a-07338e400a3f.png)

### Бесхозные корутины
До сих пор мы с вами изучали как создавать бесхозные корутины. Бесхозная корутина - это корутина, которая не привязана ни к одному игровому объекту. Выполнение такой корутины не может быть прервано, кроме как с помощью методов `Stop` или `Reset`. 

### Корутины и их владельцы
Вы можете связать корутину с любым игровым объектом, то есть сделать этот игровой объект хозяином корутины. Это значит, что выполнение корутины будет возможным только в случае если объект-хозяин активен, в противном случае корутина будет остановлена и вы не сможете перезапустить ее. Попытка запуска корутины на неактивном объекте-хозяине сгенерирует исключение.

Чтобы указать хозяина корутины укажите его первым параметром в методах `Coroutine.Create` или `Coroutine.Run`.
```
var cor = Coroutine.Run(gameObject, CountEnumerator()); // gameObject - это хозяин корутины
```
> Вы не можете изменить хозяина корутины после того как корутина была создана.

Если вам необходимо получить хозяина корутины, то вы можете использовать свойство `Owner` у объекта корутины.
```
var cor = Coroutine.Run(gameObject, CountEnumerator());
print(cor.Owner.name);
```

### Объект `CoroutinesOwner`
На самом деле **запуск** (именно запуск, с помощью метода `Run`) любой корутины будет происходить на объекте `CoroutinesOwner` (то есть внутри метода `Run` есть такая строка кода `CoroutinesOwner.Instance.StartCoroutine(RunEnumerator())`), однако он хорошо спрятан от вас и вам не нужно как либо пытаться найти его и что-либо с ним делать. Перед самым запуском вашей игры в сцене будет создан объект `CoroutinesOwner`, который будет изолирован в `DontDestroyOnLoad` сцену и скрыт в ней, так, что вы и не заметите этого. 
- Все бесхозные корутины принадлежат и запускаются на объекте `CoroutinesOwner`. 
- Корутины с хозяином принадлежат своим объектам-хозяинам, а запускаются на объекте `CoroutinesOwner`.
> Не пытайтесь как либо повлиять на объект `CoroutinesOwner`.

### Как устроено отслеживание деактивации объектов-хозяинов
Для отслеживания деактивации хозяинов корутин к ним (хозяину) добавляется скрипт `DeactivationObserver`, который в случае деактивации объекта испускает событие `Deactivated`, на которое в заранее подписана связанная с этим хозяином корутина. Корутина реагирует на событие деактивации и вызывает метод `Reset` на себе, что приводит к остановке и сбрасыванию (если это возможно) состояния корутины.

![image](https://user-images.githubusercontent.com/5365111/129879176-9adb131c-3314-4e4b-b96f-5f2df1fad66f.png)

### Вспомогательный класс `Routines`
Статический класс `Routines` хранит в себе наиболее часто используемые методы для организации логики выполнения корутин. Все методы генерируют и возвращают объект `IEnumerable`, который можно использовать подставляя в другие методы. В частности имеются следующие методы:
- `Delay` - добавляет временную задержку перед выполнением корутины.
- `FrameDelay` - добавляет кадровую задержку перед выполнением корутины.
- `Repeat` - повторяет корутину указанное количество раз.
- `Wait` - ожидает выполнение объектов `YieldInstruction` и `CustomYieldInstruction`.

Пример с `Delay`:
```
private void Start() => Coroutine.Run(Routines.Delay(1f, CountEnumerator()));

private IEnumerator CountEnumerator()
{
    for (int i = 1; i <= 3; i++)
    {
        yield return new WaitForSeconds(1f);
        print(i);
    }
}
```
В этот примере используется метод `Delay`, который добавляет секундную задержку перед выполнением перечислителя `CountEnumerator`, для этого используется строка `Routines.Delay(1f, CountEnumerator())`. Как уже говорилось выше, все методы класса `Routines` возвращают объект `IEnumerable`, поэтому, чтобы сделать из результата склейки методов `Delay` и `CountEnumerator` корутину, нужно подставить его (результат) в метод `Coroutine.Run`.

Метод `Delay` умеет также работать с Action-методами, что по сути дает вам возможность быстро организовать отложенное выполнение нужного вам метода, например:
```
private void Start() => Coroutine.Run(Routines.Delay(1f, () => print("Delayed print!")));
```

или
```
private void Start() => Coroutine.Run(Routines.Delay(1f, () => Welcome("Andrew", 29)));

private void Welcome(string name, int age) => print($"Hello {name}, you are {age} years old!");
```

![image](https://user-images.githubusercontent.com/5365111/129882932-0ade0009-9599-4226-9567-046fa6a91762.png)

Как видите это очень удобно и сокращен дублирование кода.
> Данные методы могут работать как с `IEnumerable` так и с `IEnumerator` объектами (в некоторых случаях есть исключения), однако, если вы планируете перезапуск ваших перечислителей, то необходимо использовать `IEnumerable` объекты. Мы рекомендуем всегда использовать генерацию `IEnumerable` объекта вместо `IEnumerator`.

Метод `FrameDelay` добавляет кадровую задежку перед выполнение перечислителя. К примеру, если нужно подождать 1 игровой кадр, а затем выполнить код перечислителя, то это будет выглядеть так:
```
private void Start() => Coroutine.Run(Routines.FrameDelay(1, () => print("1 frame skipped!")));
```
Данный метод также как и метод `Delay` умеет работать с Action-методами.

Метод `Repeat` повторяет указанный перечислитель указанное количество раз. Если вам нужно бесконечное повторение выполнения перечислителя, то укажите -1 в качестве параметра `count` метода `Repeat`. Пример:
```
private void Start() => Coroutine.Run(Routines.Repeat(3, WaitAndPrintEnumerator()));

private IEnumerable WaitAndPrintEnumerator()
{
    yield return new WaitForSeconds(1f);
    print("Hello!");
}
```
В результате в консоль 3 раза через каждую секунду будет выведен текст "Hello!".

![image](https://user-images.githubusercontent.com/5365111/129884060-ffa723c8-c7c7-4fe7-8400-e7b3dc37ee40.png)

Вы можете комбинировать методы `Delay`, `FrameDelay` и `Repeat` между собой, например, если нужно выполнить некую функцию 3 раза с задержкой в 1 секунду, то это будет выглядеть так:
```
private void Start() => Coroutine.Run(Routines.Repeat(3, Routines.Delay(1f, () => print(Time.time))));
```

![image](https://user-images.githubusercontent.com/5365111/129884562-3ad492a7-de74-466f-be0e-3cbe27654555.png)

Такое вложение методов друг в друга может быть неограниченным.

Метод `Wait` позволяет быстро обернуть `YieldInstrution` или `CustomYieldInstruction` объект в `IEnumerable`, который просто будет ждать их выполнения. Например, если вы хотите обернуть `YieldInstruction` объект в корутину, чтобы в дальнейшем следить за состоянием выполнения `YieldInstruction` через эту корутину, то вы можете написать такой код:
```
var coroutine = Coroutine.Run(Routines.Wait(instruction));
```
Где `instruction` это объект класса `YieldInstruction`.

### Расширения
Помимо основного пространства имен существует еще и пространство имен `Coroutines.Extensions`, в котором находятся методы расширения для классов `YieldInstruction` и `CustomYieldInstruction`. Эти методы позволяют быстро конвертировать `Coroutine`, `YieldInstruction` и `CustomYieldInstruction` друг в друга. Например:
```
var delayCoroutine = Coroutine.Run(Routines.Delay(1f, () => print("Converting")));  // Создали корутину

var yieldInstruction = delayCoroutine.WaitForComplete();                            // Получили YieldInstruction объект
var customYieldInstruction = yieldInstruction.AsCustomYieldInstruction();           // YieldInstruction конвертировали в CustomYieldInstruction
var coroutine = customYieldInstruction.AsCoroutine();                               // CustomYieldInstruction конвертировали в новый объект Coroutine
```

Такое преобразование скорее всего редко вам понадобится, однако возможность имеется.

Все! Теперь вы готовы использовать наш движок корутин, удачи!
